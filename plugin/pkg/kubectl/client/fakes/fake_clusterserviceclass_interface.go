/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/kubernetes-incubator/service-catalog/pkg/apis/servicecatalog/v1beta1"
	generated_v1beta1 "github.com/kubernetes-incubator/service-catalog/pkg/client/clientset_generated/clientset/typed/servicecatalog/v1beta1"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
)

type FakeClusterServiceClassInterface struct {
	CreateStub        func(*v1beta1.ClusterServiceClass) (*v1beta1.ClusterServiceClass, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *v1beta1.ClusterServiceClass
	}
	createReturns struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	UpdateStub        func(*v1beta1.ClusterServiceClass) (*v1beta1.ClusterServiceClass, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *v1beta1.ClusterServiceClass
	}
	updateReturns struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	UpdateStatusStub        func(*v1beta1.ClusterServiceClass) (*v1beta1.ClusterServiceClass, error)
	updateStatusMutex       sync.RWMutex
	updateStatusArgsForCall []struct {
		arg1 *v1beta1.ClusterServiceClass
	}
	updateStatusReturns struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	updateStatusReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	DeleteStub        func(name string, options *v1.DeleteOptions) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		name    string
		options *v1.DeleteOptions
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCollectionStub        func(options *v1.DeleteOptions, listOptions v1.ListOptions) error
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		options     *v1.DeleteOptions
		listOptions v1.ListOptions
	}
	deleteCollectionReturns struct {
		result1 error
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(name string, options v1.GetOptions) (*v1beta1.ClusterServiceClass, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		name    string
		options v1.GetOptions
	}
	getReturns struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	ListStub        func(opts v1.ListOptions) (*v1beta1.ClusterServiceClassList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		opts v1.ListOptions
	}
	listReturns struct {
		result1 *v1beta1.ClusterServiceClassList
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterServiceClassList
		result2 error
	}
	WatchStub        func(opts v1.ListOptions) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		opts v1.ListOptions
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 watch.Interface
		result2 error
	}
	PatchStub        func(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1beta1.ClusterServiceClass, err error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		name         string
		pt           types.PatchType
		data         []byte
		subresources []string
	}
	patchReturns struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	patchReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClusterServiceClassInterface) Create(arg1 *v1beta1.ClusterServiceClass) (*v1beta1.ClusterServiceClass, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *v1beta1.ClusterServiceClass
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeClusterServiceClassInterface) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) CreateArgsForCall(i int) *v1beta1.ClusterServiceClass {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].arg1
}

func (fake *FakeClusterServiceClassInterface) CreateReturns(result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) CreateReturnsOnCall(i int, result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterServiceClass
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) Update(arg1 *v1beta1.ClusterServiceClass) (*v1beta1.ClusterServiceClass, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *v1beta1.ClusterServiceClass
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateReturns.result1, fake.updateReturns.result2
}

func (fake *FakeClusterServiceClassInterface) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) UpdateArgsForCall(i int) *v1beta1.ClusterServiceClass {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1
}

func (fake *FakeClusterServiceClassInterface) UpdateReturns(result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) UpdateReturnsOnCall(i int, result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterServiceClass
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) UpdateStatus(arg1 *v1beta1.ClusterServiceClass) (*v1beta1.ClusterServiceClass, error) {
	fake.updateStatusMutex.Lock()
	ret, specificReturn := fake.updateStatusReturnsOnCall[len(fake.updateStatusArgsForCall)]
	fake.updateStatusArgsForCall = append(fake.updateStatusArgsForCall, struct {
		arg1 *v1beta1.ClusterServiceClass
	}{arg1})
	fake.recordInvocation("UpdateStatus", []interface{}{arg1})
	fake.updateStatusMutex.Unlock()
	if fake.UpdateStatusStub != nil {
		return fake.UpdateStatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateStatusReturns.result1, fake.updateStatusReturns.result2
}

func (fake *FakeClusterServiceClassInterface) UpdateStatusCallCount() int {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return len(fake.updateStatusArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) UpdateStatusArgsForCall(i int) *v1beta1.ClusterServiceClass {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return fake.updateStatusArgsForCall[i].arg1
}

func (fake *FakeClusterServiceClassInterface) UpdateStatusReturns(result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.UpdateStatusStub = nil
	fake.updateStatusReturns = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) UpdateStatusReturnsOnCall(i int, result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.UpdateStatusStub = nil
	if fake.updateStatusReturnsOnCall == nil {
		fake.updateStatusReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterServiceClass
			result2 error
		})
	}
	fake.updateStatusReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) Delete(name string, options *v1.DeleteOptions) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		name    string
		options *v1.DeleteOptions
	}{name, options})
	fake.recordInvocation("Delete", []interface{}{name, options})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(name, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeClusterServiceClassInterface) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) DeleteArgsForCall(i int) (string, *v1.DeleteOptions) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].name, fake.deleteArgsForCall[i].options
}

func (fake *FakeClusterServiceClassInterface) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterServiceClassInterface) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterServiceClassInterface) DeleteCollection(options *v1.DeleteOptions, listOptions v1.ListOptions) error {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		options     *v1.DeleteOptions
		listOptions v1.ListOptions
	}{options, listOptions})
	fake.recordInvocation("DeleteCollection", []interface{}{options, listOptions})
	fake.deleteCollectionMutex.Unlock()
	if fake.DeleteCollectionStub != nil {
		return fake.DeleteCollectionStub(options, listOptions)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteCollectionReturns.result1
}

func (fake *FakeClusterServiceClassInterface) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) DeleteCollectionArgsForCall(i int) (*v1.DeleteOptions, v1.ListOptions) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return fake.deleteCollectionArgsForCall[i].options, fake.deleteCollectionArgsForCall[i].listOptions
}

func (fake *FakeClusterServiceClassInterface) DeleteCollectionReturns(result1 error) {
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterServiceClassInterface) DeleteCollectionReturnsOnCall(i int, result1 error) {
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterServiceClassInterface) Get(name string, options v1.GetOptions) (*v1beta1.ClusterServiceClass, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		name    string
		options v1.GetOptions
	}{name, options})
	fake.recordInvocation("Get", []interface{}{name, options})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *FakeClusterServiceClassInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) GetArgsForCall(i int) (string, v1.GetOptions) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].name, fake.getArgsForCall[i].options
}

func (fake *FakeClusterServiceClassInterface) GetReturns(result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) GetReturnsOnCall(i int, result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterServiceClass
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) List(opts v1.ListOptions) (*v1beta1.ClusterServiceClassList, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		opts v1.ListOptions
	}{opts})
	fake.recordInvocation("List", []interface{}{opts})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listReturns.result1, fake.listReturns.result2
}

func (fake *FakeClusterServiceClassInterface) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) ListArgsForCall(i int) v1.ListOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].opts
}

func (fake *FakeClusterServiceClassInterface) ListReturns(result1 *v1beta1.ClusterServiceClassList, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 *v1beta1.ClusterServiceClassList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) ListReturnsOnCall(i int, result1 *v1beta1.ClusterServiceClassList, result2 error) {
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterServiceClassList
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterServiceClassList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) Watch(opts v1.ListOptions) (watch.Interface, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		opts v1.ListOptions
	}{opts})
	fake.recordInvocation("Watch", []interface{}{opts})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.watchReturns.result1, fake.watchReturns.result2
}

func (fake *FakeClusterServiceClassInterface) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) WatchArgsForCall(i int) v1.ListOptions {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return fake.watchArgsForCall[i].opts
}

func (fake *FakeClusterServiceClassInterface) WatchReturns(result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) WatchReturnsOnCall(i int, result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 watch.Interface
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1beta1.ClusterServiceClass, err error) {
	var dataCopy []byte
	if data != nil {
		dataCopy = make([]byte, len(data))
		copy(dataCopy, data)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		name         string
		pt           types.PatchType
		data         []byte
		subresources []string
	}{name, pt, dataCopy, subresources})
	fake.recordInvocation("Patch", []interface{}{name, pt, dataCopy, subresources})
	fake.patchMutex.Unlock()
	if fake.PatchStub != nil {
		return fake.PatchStub(name, pt, data, subresources...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.patchReturns.result1, fake.patchReturns.result2
}

func (fake *FakeClusterServiceClassInterface) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakeClusterServiceClassInterface) PatchArgsForCall(i int) (string, types.PatchType, []byte, []string) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return fake.patchArgsForCall[i].name, fake.patchArgsForCall[i].pt, fake.patchArgsForCall[i].data, fake.patchArgsForCall[i].subresources
}

func (fake *FakeClusterServiceClassInterface) PatchReturns(result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) PatchReturnsOnCall(i int, result1 *v1beta1.ClusterServiceClass, result2 error) {
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterServiceClass
			result2 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterServiceClass
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceClassInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClusterServiceClassInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ generated_v1beta1.ClusterServiceClassInterface = new(FakeClusterServiceClassInterface)
